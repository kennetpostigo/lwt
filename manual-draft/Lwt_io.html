<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Lwt_gc.html">
<link rel="next" href="Lwt_log.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Pa_lwt" rel="Chapter" href="Pa_lwt.html">
<link title="Lwt" rel="Chapter" href="Lwt.html">
<link title="Lwt_condition" rel="Chapter" href="Lwt_condition.html">
<link title="Lwt_list" rel="Chapter" href="Lwt_list.html">
<link title="Lwt_mutex" rel="Chapter" href="Lwt_mutex.html">
<link title="Lwt_mvar" rel="Chapter" href="Lwt_mvar.html">
<link title="Lwt_pool" rel="Chapter" href="Lwt_pool.html">
<link title="Lwt_pqueue" rel="Chapter" href="Lwt_pqueue.html">
<link title="Lwt_result" rel="Chapter" href="Lwt_result.html">
<link title="Lwt_sequence" rel="Chapter" href="Lwt_sequence.html">
<link title="Lwt_stream" rel="Chapter" href="Lwt_stream.html">
<link title="Lwt_switch" rel="Chapter" href="Lwt_switch.html">
<link title="Lwt_glib" rel="Chapter" href="Lwt_glib.html">
<link title="Lwt_log_core" rel="Chapter" href="Lwt_log_core.html">
<link title="Lwt_log_rules" rel="Chapter" href="Lwt_log_rules.html">
<link title="Ppx_lwt" rel="Chapter" href="Ppx_lwt.html">
<link title="Lwt_preemptive" rel="Chapter" href="Lwt_preemptive.html">
<link title="Lwt_react" rel="Chapter" href="Lwt_react.html">
<link title="Lwt_ssl" rel="Chapter" href="Lwt_ssl.html">
<link title="Lwt_bytes" rel="Chapter" href="Lwt_bytes.html">
<link title="Lwt_chan" rel="Chapter" href="Lwt_chan.html">
<link title="Lwt_daemon" rel="Chapter" href="Lwt_daemon.html">
<link title="Lwt_engine" rel="Chapter" href="Lwt_engine.html">
<link title="Lwt_gc" rel="Chapter" href="Lwt_gc.html">
<link title="Lwt_io" rel="Chapter" href="Lwt_io.html">
<link title="Lwt_log" rel="Chapter" href="Lwt_log.html">
<link title="Lwt_main" rel="Chapter" href="Lwt_main.html">
<link title="Lwt_process" rel="Chapter" href="Lwt_process.html">
<link title="Lwt_sys" rel="Chapter" href="Lwt_sys.html">
<link title="Lwt_throttle" rel="Chapter" href="Lwt_throttle.html">
<link title="Lwt_timeout" rel="Chapter" href="Lwt_timeout.html">
<link title="Lwt_unix" rel="Chapter" href="Lwt_unix.html"><link title="Types" rel="Section" href="#2_Types">
<link title="Well-known instances" rel="Section" href="#2_Wellknowninstances">
<link title="Channels creation/manipulation" rel="Section" href="#2_Channelscreationmanipulation">
<link title="Random access" rel="Section" href="#2_Randomaccess">
<link title="Reading" rel="Section" href="#2_Reading">
<link title="Writing" rel="Section" href="#2_Writing">
<link title="Printing" rel="Section" href="#2_Printing">
<link title="Utilities" rel="Section" href="#2_Utilities">
<link title="File utilities" rel="Section" href="#2_Fileutilities">
<link title="Input/output of integers" rel="Section" href="#2_Inputoutputofintegers">
<link title="Low-level access to the internal buffer" rel="Section" href="#2_Lowlevelaccesstotheinternalbuffer">
<link title="Misc" rel="Section" href="#2_Misc">
<link title="Deprecated" rel="Section" href="#2_Deprecated">
<title>Lwt_io</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Lwt_gc.html" title="Lwt_gc">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Lwt_log.html" title="Lwt_log">Next</a>
</div>
<h1>Module <a href="type_Lwt_io.html">Lwt_io</a></h1>

<pre><span class="keyword">module</span> Lwt_io: <code class="code"><span class="keyword">sig</span></code> <a href="Lwt_io.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Buffered byte channels<br>
</div>
<hr width="100%">
<br>
A <b>channel</b> is a high-level object for performing input/output
    (IO). It allows to read/write from/to the outside world in an
    efficient way, by minimising the number of system calls.
<p>

    An <b>output channel</b> is used to send data and an <b>input
    channel</b> is used to receive data.
<p>

    If you are familiar with buffered channels you may be familiar too
    with the <b>flush</b> operation. Note that byte channels of this
    module are automatically flushed when there is nothing else to do
    (i.e. before the program becomes idle), so this means that you no
    longer have to write:
<p>

    <pre class="codepre"><code class="code">      eprintf <span class="string">"log message\n"</span>;
      flush stderr;
    </code></pre>
<p>

    to have your messages displayed.
<p>

    Note about errors: input functions of this module raise
    <code class="code"><span class="constructor">End_of_file</span></code> when the end-of-file is reached (i.e. when the read
    function returns <code class="code">0</code>). Other exceptions are ones caused by the
    backend read/write functions, such as <code class="code"><span class="constructor">Unix</span>.<span class="constructor">Unix_error</span></code>.<br>

<pre><span id="EXCEPTIONChannel_closed"><span class="keyword">exception</span> Channel_closed</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
Exception raised when a channel is closed. The parameter is a
      description of the channel.<br>
</div>
<br>
<h2 id="2_Types">Types</h2><br>

<pre><span id="TYPEchannel"><span class="keyword">type</span> <code class="type">'mode</code> channel</span> </pre>
<div class="info ">
Type of buffered byte channels<br>
</div>


<pre><span id="TYPEinput"><span class="keyword">type</span> <code class="type"></code>input</span> </pre>
<div class="info ">
Input mode<br>
</div>


<pre><span id="TYPEoutput"><span class="keyword">type</span> <code class="type"></code>output</span> </pre>
<div class="info ">
Output mode<br>
</div>


<pre><code><span id="TYPEmode"><span class="keyword">type</span> <code class="type">'a</code> mode</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTmode.Input"><span class="constructor">Input</span></span> <span class="keyword">:</span> <code class="type"><a href="Lwt_io.html#TYPEinput">input</a> <a href="Lwt_io.html#TYPEmode">mode</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTmode.Output"><span class="constructor">Output</span></span> <span class="keyword">:</span> <code class="type"><a href="Lwt_io.html#TYPEoutput">output</a> <a href="Lwt_io.html#TYPEmode">mode</a></code></code></td>

</tr></table>

<div class="info ">
Channel mode<br>
</div>


<pre><span id="VALinput"><span class="keyword">val</span> input</span> : <code class="type"><a href="Lwt_io.html#TYPEinput">input</a> <a href="Lwt_io.html#TYPEmode">mode</a></code></pre><div class="info ">
<code class="code">input</code> input mode representation<br>
</div>

<pre><span id="VALoutput"><span class="keyword">val</span> output</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput">output</a> <a href="Lwt_io.html#TYPEmode">mode</a></code></pre><div class="info ">
<code class="code">output</code> output mode representation<br>
</div>

<pre><span id="TYPEinput_channel"><span class="keyword">type</span> <code class="type"></code>input_channel</span> = <code class="type"><a href="Lwt_io.html#TYPEinput">input</a> <a href="Lwt_io.html#TYPEchannel">channel</a></code> </pre>
<div class="info ">
Type of input channels<br>
</div>


<pre><span id="TYPEoutput_channel"><span class="keyword">type</span> <code class="type"></code>output_channel</span> = <code class="type"><a href="Lwt_io.html#TYPEoutput">output</a> <a href="Lwt_io.html#TYPEchannel">channel</a></code> </pre>
<div class="info ">
Type of output channels<br>
</div>


<pre><span id="VALmode"><span class="keyword">val</span> mode</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> 'a <a href="Lwt_io.html#TYPEmode">mode</a></code></pre><div class="info ">
<code class="code">mode&nbsp;ch</code> returns the mode of a channel<br>
</div>
<br>
<h2 id="2_Wellknowninstances">Well-known instances</h2><br>

<pre><span id="VALstdin"><span class="keyword">val</span> stdin</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a></code></pre><div class="info ">
The standard input, it reads data from <a href="Lwt_unix.html#VALstdin"><code class="code"><span class="constructor">Lwt_unix</span>.stdin</code></a><br>
</div>

<pre><span id="VALstdout"><span class="keyword">val</span> stdout</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
The standard output, it writes data to <a href="Lwt_unix.html#VALstdout"><code class="code"><span class="constructor">Lwt_unix</span>.stdout</code></a><br>
</div>

<pre><span id="VALstderr"><span class="keyword">val</span> stderr</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
The standard output for error messages, it writes data to
      <a href="Lwt_unix.html#VALstderr"><code class="code"><span class="constructor">Lwt_unix</span>.stderr</code></a><br>
</div>

<pre><span id="VALzero"><span class="keyword">val</span> zero</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a></code></pre><div class="info ">
Inputs which returns always <code class="code">'\x00'</code><br>
</div>

<pre><span id="VALnull"><span class="keyword">val</span> null</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
Output which drops everything<br>
</div>
<br>
<h2 id="2_Channelscreationmanipulation">Channels creation/manipulation</h2><br>

<pre><span id="VALpipe"><span class="keyword">val</span> pipe</span> : <code class="type">?in_buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?out_buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       unit -> <a href="Lwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Lwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
<code class="code">pipe&nbsp;?in_buffer&nbsp;?out_buffer&nbsp;()</code> creates a pipe using
      <a href="Lwt_unix.html#VALpipe"><code class="code"><span class="constructor">Lwt_unix</span>.pipe</code></a> and makes two channels from the two returned file
      descriptors<br>
</div>

<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">?buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?close:(unit -> unit <a href="Lwt.html#TYPEt">Lwt.t</a>) -><br>       ?seek:(int64 -> Unix.seek_command -> int64 <a href="Lwt.html#TYPEt">Lwt.t</a>) -><br>       mode:'mode <a href="Lwt_io.html#TYPEmode">mode</a> -><br>       (<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -> int -> int -> int <a href="Lwt.html#TYPEt">Lwt.t</a>) -> 'mode <a href="Lwt_io.html#TYPEchannel">channel</a></code></pre><div class="info ">
<code class="code">make&nbsp;?buffer&nbsp;?close&nbsp;~mode&nbsp;perform_io</code> is the
      main function for creating new channels.<br>
</div>
<div class="param_info"><code class="code">buffer</code> : user-supplied buffer. When this argument is
      present, its value will be used as the buffer for the created
      channel. The size of buffer must conform to the limitations
      described in <a href="Lwt_io.html#VALset_default_buffer_size"><code class="code"><span class="constructor">Lwt_io</span>.set_default_buffer_size</code></a>.  When this argument is
      not present, a new internal buffer of default size will be
      allocated for this channel.
<p>

      Warning: do not use the same buffer for simultaneous work with more
      than one channel.
<p>

      There are other functions in this module that take a <code class="code">buffer</code>
      argument, sharing the same semantics.</div>
<div class="param_info"><code class="code">close</code> : close function of the channel. It defaults to
      <code class="code"><span class="constructor">Lwt</span>.return</code></div>
<div class="param_info"><code class="code">seek</code> : same meaning as <code class="code"><span class="constructor">Unix</span>.lseek</code></div>
<div class="param_info"><code class="code">mode</code> : either <a href="Lwt_io.html#VALinput"><code class="code"><span class="constructor">Lwt_io</span>.input</code></a> or <a href="Lwt_io.html#VALoutput"><code class="code"><span class="constructor">Lwt_io</span>.output</code></a></div>

<pre><span id="VALof_bytes"><span class="keyword">val</span> of_bytes</span> : <code class="type">mode:'mode <a href="Lwt_io.html#TYPEmode">mode</a> -> <a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -> 'mode <a href="Lwt_io.html#TYPEchannel">channel</a></code></pre><div class="info ">
Create a channel from a byte array. Reading/writing is done
      directly on the provided array.<br>
</div>

<pre><span id="VALof_fd"><span class="keyword">val</span> of_fd</span> : <code class="type">?buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?close:(unit -> unit <a href="Lwt.html#TYPEt">Lwt.t</a>) -><br>       mode:'mode <a href="Lwt_io.html#TYPEmode">mode</a> -> <a href="Lwt_unix.html#TYPEfile_descr">Lwt_unix.file_descr</a> -> 'mode <a href="Lwt_io.html#TYPEchannel">channel</a></code></pre><div class="info ">
<code class="code">of_fd&nbsp;?buffer&nbsp;?close&nbsp;~mode&nbsp;fd</code> creates a channel from a
      file descriptor.<br>
</div>
<div class="param_info"><code class="code">close</code> : defaults to closing the file descriptor.</div>

<pre><span id="VALof_unix_fd"><span class="keyword">val</span> of_unix_fd</span> : <code class="type">?buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?close:(unit -> unit <a href="Lwt.html#TYPEt">Lwt.t</a>) -><br>       mode:'mode <a href="Lwt_io.html#TYPEmode">mode</a> -> Unix.file_descr -> 'mode <a href="Lwt_io.html#TYPEchannel">channel</a></code></pre><div class="info ">
<code class="code">of_unix_fd&nbsp;?buffer&nbsp;?close&nbsp;~mode&nbsp;fd</code> is a short-hand for:
<p>

      <code class="code">of_fd&nbsp;?buffer&nbsp;?close&nbsp;(<span class="constructor">Lwt_unix</span>.of_unix_file_descr&nbsp;fd)</code><br>
</div>

<pre><span id="VALclose"><span class="keyword">val</span> close</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">close&nbsp;ch</code> closes the given channel. If <code class="code">ch</code> is an output
      channel, it performs all pending actions, flushes it and closes
      it. If <code class="code">ch</code> is an input channel, it just closes it immediately.
<p>

      <code class="code">close</code> returns the result of the close function of the
      channel. Multiple calls to <code class="code">close</code> will return exactly the same
      value.
<p>

      Note: you cannot use <code class="code">close</code> on channels obtained with
      <a href="Lwt_io.html#VALatomic"><code class="code"><span class="constructor">Lwt_io</span>.atomic</code></a>.<br>
</div>

<pre><span id="VALabort"><span class="keyword">val</span> abort</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">abort&nbsp;ch</code> abort current operations and close the channel
      immediately.<br>
</div>

<pre><span id="VALatomic"><span class="keyword">val</span> atomic</span> : <code class="type">('a <a href="Lwt_io.html#TYPEchannel">channel</a> -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a>) -> 'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">atomic&nbsp;f</code> transforms a sequence of io operations into one
      single atomic io operation.
<p>

      Note:<ul>
<li>the channel passed to <code class="code">f</code> is invalid after <code class="code">f</code> terminates</li>
<li><code class="code">atomic</code> can be called inside another <code class="code">atomic</code></li>
</ul>
<br>
</div>

<pre><span id="VALfile_length"><span class="keyword">val</span> file_length</span> : <code class="type">string -> int64 <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
Returns the length of a file<br>
</div>

<pre><span id="VALbuffered"><span class="keyword">val</span> buffered</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> int</code></pre><div class="info ">
<code class="code">buffered&nbsp;oc</code> returns the number of bytes in the buffer<br>
</div>

<pre><span id="VALflush"><span class="keyword">val</span> flush</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">flush&nbsp;oc</code> performs all pending writes on <code class="code">oc</code><br>
</div>

<pre><span id="VALflush_all"><span class="keyword">val</span> flush_all</span> : <code class="type">unit -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">flush_all&nbsp;()</code> flushes all open output channels<br>
</div>

<pre><span id="VALbuffer_size"><span class="keyword">val</span> buffer_size</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> int</code></pre><div class="info ">
Returns the size of the internal buffer.<br>
</div>

<pre><span id="VALresize_buffer"><span class="keyword">val</span> resize_buffer</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> int -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
Resize the internal buffer to the given size<br>
</div>

<pre><span id="VALis_busy"><span class="keyword">val</span> is_busy</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> bool</code></pre><div class="info ">
<code class="code">is_busy&nbsp;channel</code> returns whether the given channel is currently
      busy. A channel is busy when there is at least one job using it
      that has not yet terminated.<br>
</div>
<br>
<h2 id="2_Randomaccess">Random access</h2><br>

<pre><span id="VALposition"><span class="keyword">val</span> position</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> int64</code></pre><div class="info ">
<code class="code">position&nbsp;ch</code> Returns the current position in the channel.<br>
</div>

<pre><span id="VALset_position"><span class="keyword">val</span> set_position</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> int64 -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">set_position&nbsp;ch&nbsp;pos</code> Sets the position in the output channel. This
      does not work if the channel does not support random access.<br>
</div>

<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> int64 <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
Returns the length of the channel in bytes<br>
</div>
<br>
<h2 id="2_Reading">Reading</h2><br>
<br>
Note: except for functions dealing with streams (<a href="Lwt_io.html#VALread_chars"><code class="code"><span class="constructor">Lwt_io</span>.read_chars</code></a> and
    <a href="Lwt_io.html#VALread_lines"><code class="code"><span class="constructor">Lwt_io</span>.read_lines</code></a>) all functions are <b>atomic</b>.<br>

<pre><span id="VALread_char"><span class="keyword">val</span> read_char</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> char <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">read_char&nbsp;ic</code> reads the next character of <code class="code">ic</code>.<br>
<b>Raises</b> <code>End_of_file</code> if the end of the file is reached<br>
</div>

<pre><span id="VALread_char_opt"><span class="keyword">val</span> read_char_opt</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> char option <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
Same as <code class="code">read_byte</code> but does not raise <code class="code"><span class="constructor">End_of_file</span></code> on end of
      input<br>
</div>

<pre><span id="VALread_chars"><span class="keyword">val</span> read_chars</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> char <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a></code></pre><div class="info ">
<code class="code">read_chars&nbsp;ic</code> returns a stream holding all characters of
      <code class="code">ic</code><br>
</div>

<pre><span id="VALread_line"><span class="keyword">val</span> read_line</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> string <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">read_line&nbsp;ic</code> reads one complete line from <code class="code">ic</code> and returns it
      without the end of line. End of line is either <code class="code"><span class="string">"\n"</span></code> or
      <code class="code"><span class="string">"\r\n"</span></code>.
<p>

      If the end of line is reached before reading any character,
      <code class="code"><span class="constructor">End_of_file</span></code> is raised. If it is reached before reading an end
      of line but characters have already been read, they are
      returned.<br>
</div>

<pre><span id="VALread_line_opt"><span class="keyword">val</span> read_line_opt</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> string option <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
Same as <a href="Lwt_io.html#VALread_line"><code class="code"><span class="constructor">Lwt_io</span>.read_line</code></a> but do not raise <code class="code"><span class="constructor">End_of_file</span></code> on end of
      input.<br>
</div>

<pre><span id="VALread_lines"><span class="keyword">val</span> read_lines</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> string <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a></code></pre><div class="info ">
<code class="code">read_lines&nbsp;ic</code> returns a stream holding all lines of <code class="code">ic</code><br>
</div>

<pre><span id="VALread"><span class="keyword">val</span> read</span> : <code class="type">?count:int -> <a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> string <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">read&nbsp;?count&nbsp;ic</code> reads at most <code class="code">count</code> characters from <code class="code">ic</code>. It
      returns <code class="code"><span class="string">""</span></code> if the end of input is reached. If <code class="code">count</code> is not
      specified, it reads all bytes until the end of input.<br>
</div>

<pre><span id="VALread_into"><span class="keyword">val</span> read_into</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> bytes -> int -> int -> int <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">read_into&nbsp;ic&nbsp;buffer&nbsp;offset&nbsp;length</code> reads up to <code class="code">length</code> bytes,
      stores them in <code class="code">buffer</code> at offset <code class="code">offset</code>, and returns the
      number of bytes read.
<p>

      Note: <code class="code">read_into</code> does not raise <code class="code"><span class="constructor">End_of_file</span></code>, it returns a
      length of <code class="code">0</code> instead.<br>
</div>

<pre><span id="VALread_into_exactly"><span class="keyword">val</span> read_into_exactly</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> bytes -> int -> int -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">read_into_exactly&nbsp;ic&nbsp;buffer&nbsp;offset&nbsp;length</code> reads exactly
      <code class="code">length</code> bytes and stores them in <code class="code">buffer</code> at offset <code class="code">offset</code>.<br>
<b>Raises</b> <code>End_of_file</code> on end of input<br>
</div>

<pre><span id="VALread_value"><span class="keyword">val</span> read_value</span> : <code class="type"><a href="Lwt_io.html#TYPEinput_channel">input_channel</a> -> 'a <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">read_value&nbsp;channel</code> reads a marshaled value from <code class="code">channel</code>; it corresponds
    to the standard library's
    <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALfrom_channel"> <code class="code"><span class="constructor">Marshal</span>.from_channel</code></a>.
    The corresponding writing function is <a href="Lwt_io.html#VALwrite_value"><code class="code"><span class="constructor">Lwt_io</span>.write_value</code></a>.
<p>

    Note that reading marshaled values is <em>not</em>, in general, type-safe. See
    the warning in the description of module
    <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html">
    <code class="code"><span class="constructor">Marshal</span></code></a> for details. The short version is: if you read a value of one
    type, such as <code class="code">string</code>, when a value of another type, such as <code class="code">int</code> has
    actually been marshaled to <code class="code">channel</code>, you may get arbitrary behavior,
    including segmentation faults, access violations, security bugs, etc.<br>
</div>
<br>
<h2 id="2_Writing">Writing</h2><br>
<br>
Note: as for reading functions, all functions except
    <a href="Lwt_io.html#VALwrite_chars"><code class="code"><span class="constructor">Lwt_io</span>.write_chars</code></a> and <a href="Lwt_io.html#VALwrite_lines"><code class="code"><span class="constructor">Lwt_io</span>.write_lines</code></a> are <b>atomic</b>.
<p>

    For example if you use <a href="Lwt_io.html#VALwrite_line"><code class="code"><span class="constructor">Lwt_io</span>.write_line</code></a> in two different threads, the
    two operations will be serialized, and lines cannot be mixed.<br>

<pre><span id="VALwrite_char"><span class="keyword">val</span> write_char</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> char -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write_char&nbsp;oc&nbsp;char</code> writes <code class="code">char</code> on <code class="code">oc</code><br>
</div>

<pre><span id="VALwrite_chars"><span class="keyword">val</span> write_chars</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> char <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write_chars&nbsp;oc&nbsp;chars</code> writes all characters of <code class="code">chars</code> on
      <code class="code">oc</code><br>
</div>

<pre><span id="VALwrite"><span class="keyword">val</span> write</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write&nbsp;oc&nbsp;str</code> writes all characters of <code class="code">str</code> on <code class="code">oc</code><br>
</div>

<pre><span id="VALwrite_line"><span class="keyword">val</span> write_line</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write_line&nbsp;oc&nbsp;str</code> writes <code class="code">str</code> on <code class="code">oc</code> followed by a
      new-line.<br>
</div>

<pre><span id="VALwrite_lines"><span class="keyword">val</span> write_lines</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write_lines&nbsp;oc&nbsp;lines</code> writes all lines of <code class="code">lines</code> to <code class="code">oc</code><br>
</div>

<pre><span id="VALwrite_from"><span class="keyword">val</span> write_from</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> bytes -> int -> int -> int <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write_from&nbsp;oc&nbsp;buffer&nbsp;offset&nbsp;length</code> writes up to <code class="code">length</code> bytes
      to <code class="code">oc</code>, from <code class="code">buffer</code> at offset <code class="code">offset</code> and returns the number
      of bytes actually written<br>
</div>

<pre><span id="VALwrite_from_string"><span class="keyword">val</span> write_from_string</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> int -> int -> int <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
See <a href="Lwt_io.html#VALwrite"><code class="code"><span class="constructor">Lwt_io</span>.write</code></a>.<br>
</div>

<pre><span id="VALwrite_from_exactly"><span class="keyword">val</span> write_from_exactly</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> bytes -> int -> int -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write_from_exactly&nbsp;oc&nbsp;buffer&nbsp;offset&nbsp;length</code> writes all <code class="code">length</code>
      bytes from <code class="code">buffer</code> at offset <code class="code">offset</code> to <code class="code">oc</code><br>
</div>

<pre><span id="VALwrite_from_string_exactly"><span class="keyword">val</span> write_from_string_exactly</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> int -> int -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
See <a href="Lwt_io.html#VALwrite_from_exactly"><code class="code"><span class="constructor">Lwt_io</span>.write_from_exactly</code></a>.<br>
</div>

<pre><span id="VALwrite_value"><span class="keyword">val</span> write_value</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> ?flags:Marshal.extern_flags list -> 'a -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">write_value&nbsp;channel&nbsp;?flags&nbsp;v</code> writes <code class="code">v</code> to <code class="code">channel</code> using the <code class="code"><span class="constructor">Marshal</span></code>
    module of the standard library. See
    <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALto_channel">
    <code class="code"><span class="constructor">Marshal</span>.to_channel</code></a> for an explanation of <code class="code">?flags</code>.
<p>

    The corresponding reading function is <a href="Lwt_io.html#VALread_value"><code class="code"><span class="constructor">Lwt_io</span>.read_value</code></a>. See warnings about type
    safety in the description of <a href="Lwt_io.html#VALread_value"><code class="code"><span class="constructor">Lwt_io</span>.read_value</code></a>.<br>
</div>
<br>
<h2 id="2_Printing">Printing</h2><br>
<br>
These functions are basically helpers. Also you may prefer
    using the name <a href="Lwt_io.html#VALprintl"><code class="code"><span class="constructor">Lwt_io</span>.printl</code></a> rather than <a href="Lwt_io.html#VALwrite_line"><code class="code"><span class="constructor">Lwt_io</span>.write_line</code></a> because it is
    shorter.
<p>

    The general name of a printing function is <code class="code">&lt;prefix&gt;print&lt;suffixes&gt;</code>,
<p>

    where <code class="code">&lt;prefix&gt;</code> is one of:<ul>
<li><code class="code"><span class="string">'f'</span></code>, which means that the function takes as argument a channel</li>
<li>nothing, which means that the function prints on <a href="Lwt_io.html#VALstdout"><code class="code"><span class="constructor">Lwt_io</span>.stdout</code></a></li>
<li><code class="code"><span class="string">'e'</span></code>, which means that the function prints on <a href="Lwt_io.html#VALstderr"><code class="code"><span class="constructor">Lwt_io</span>.stderr</code></a></li>
</ul>

    and <code class="code">&lt;suffixes&gt;</code> is a combination of:<ul>
<li><code class="code"><span class="string">'l'</span></code> which means that a new-line character is printed after the message</li>
<li><code class="code"><span class="string">'f'</span></code> which means that the function takes as argument a <b>format</b> instead
    of a string</li>
</ul>
<br>

<pre><span id="VALfprint"><span class="keyword">val</span> fprint</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
<pre><span id="VALfprintl"><span class="keyword">val</span> fprintl</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
<pre><span id="VALfprintf"><span class="keyword">val</span> fprintf</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -><br>       ('a, unit, string, unit <a href="Lwt.html#TYPEt">Lwt.t</a>) Pervasives.format4 -> 'a</code></pre>
<pre><span id="VALfprintlf"><span class="keyword">val</span> fprintlf</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -><br>       ('a, unit, string, unit <a href="Lwt.html#TYPEt">Lwt.t</a>) Pervasives.format4 -> 'a</code></pre>
<pre><span id="VALprint"><span class="keyword">val</span> print</span> : <code class="type">string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
<pre><span id="VALprintl"><span class="keyword">val</span> printl</span> : <code class="type">string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
<pre><span id="VALprintf"><span class="keyword">val</span> printf</span> : <code class="type">('a, unit, string, unit <a href="Lwt.html#TYPEt">Lwt.t</a>) Pervasives.format4 -> 'a</code></pre>
<pre><span id="VALprintlf"><span class="keyword">val</span> printlf</span> : <code class="type">('a, unit, string, unit <a href="Lwt.html#TYPEt">Lwt.t</a>) Pervasives.format4 -> 'a</code></pre>
<pre><span id="VALeprint"><span class="keyword">val</span> eprint</span> : <code class="type">string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
<pre><span id="VALeprintl"><span class="keyword">val</span> eprintl</span> : <code class="type">string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
<pre><span id="VALeprintf"><span class="keyword">val</span> eprintf</span> : <code class="type">('a, unit, string, unit <a href="Lwt.html#TYPEt">Lwt.t</a>) Pervasives.format4 -> 'a</code></pre>
<pre><span id="VALeprintlf"><span class="keyword">val</span> eprintlf</span> : <code class="type">('a, unit, string, unit <a href="Lwt.html#TYPEt">Lwt.t</a>) Pervasives.format4 -> 'a</code></pre><br>
<h2 id="2_Utilities">Utilities</h2><br>

<pre><span id="VALhexdump_stream"><span class="keyword">val</span> hexdump_stream</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> char <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">hexdump_stream&nbsp;oc&nbsp;byte_stream</code> produces the same output as the
      command <code class="code">hexdump&nbsp;-<span class="constructor">C</span></code>.<br>
</div>

<pre><span id="VALhexdump"><span class="keyword">val</span> hexdump</span> : <code class="type"><a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">hexdump&nbsp;oc&nbsp;str&nbsp;=&nbsp;hexdump_stream&nbsp;oc&nbsp;(<span class="constructor">Lwt_stream</span>.of_string&nbsp;str)</code><br>
</div>
<br>
<h2 id="2_Fileutilities">File utilities</h2><br>

<pre><span id="TYPEfile_name"><span class="keyword">type</span> <code class="type"></code>file_name</span> = <code class="type">string</code> </pre>
<div class="info ">
Type of file names<br>
</div>


<pre><span id="VALopen_file"><span class="keyword">val</span> open_file</span> : <code class="type">?buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?flags:Unix.open_flag list -><br>       ?perm:Unix.file_perm -><br>       mode:'a <a href="Lwt_io.html#TYPEmode">mode</a> -> <a href="Lwt_io.html#TYPEfile_name">file_name</a> -> 'a <a href="Lwt_io.html#TYPEchannel">channel</a> <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">open_file&nbsp;?buffer&nbsp;?flags&nbsp;?perm&nbsp;~mode&nbsp;filename</code> opens the
      file with name <code class="code">filename</code> and returns a channel for
      reading/writing it.<br>
<b>Raises</b> <code>Unix.Unix_error</code> on error.<br>
</div>

<pre><span id="VALwith_file"><span class="keyword">val</span> with_file</span> : <code class="type">?buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?flags:Unix.open_flag list -><br>       ?perm:Unix.file_perm -><br>       mode:'a <a href="Lwt_io.html#TYPEmode">mode</a> -><br>       <a href="Lwt_io.html#TYPEfile_name">file_name</a> -> ('a <a href="Lwt_io.html#TYPEchannel">channel</a> -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a>) -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">with_file&nbsp;?buffer&nbsp;?flags&nbsp;?perm&nbsp;~mode&nbsp;filename&nbsp;f</code> opens a
      file and passes the channel to <code class="code">f</code>. It is ensured that the
      channel is closed when <code class="code">f&nbsp;ch</code> terminates (even if it fails).<br>
</div>

<pre><span id="VALopen_temp_file"><span class="keyword">val</span> open_temp_file</span> : <code class="type">?buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?flags:Unix.open_flag list -><br>       ?perm:Unix.file_perm -><br>       ?temp_dir:string -><br>       ?prefix:string -> unit -> (string * <a href="Lwt_io.html#TYPEoutput_channel">output_channel</a>) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">open_temp_file&nbsp;()</code> starts creating a new temporary file, and evaluates to a
    promise for the pair of the file's name, and an output channel for writing
    to the file.
<p>

    The caller should take care to delete the file later. Alternatively, see
    <a href="Lwt_io.html#VALwith_temp_file"><code class="code"><span class="constructor">Lwt_io</span>.with_temp_file</code></a>.
<p>

    The <code class="code">?buffer</code> and <code class="code">?perm</code> arguments are passed directly to an internal call
    to <code class="code"><span class="constructor">Lwt</span>.io.open_file</code>.
<p>

    If not specified, <code class="code">?flags</code> defaults to
    <code class="code">[<span class="constructor">O_CREATE</span>;&nbsp;<span class="constructor">O_EXCL</span>;&nbsp;<span class="constructor">O_WRONLY</span>;&nbsp;<span class="constructor">O_CLOEXEC</span>]</code>. If specified, the specified flags
    are used exactly. Note that these should typically contain at least
    <code class="code"><span class="constructor">O_CREAT</span></code> and <code class="code"><span class="constructor">O_EXCL</span></code>, otherwise <code class="code">open_temp_file</code> may open an existing
    file.
<p>

    <code class="code">?temp_dir</code> can be used to choose the directory in which the file is
    created. For the current directory, use
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALcurrent_dir_name">
    <code class="code"><span class="constructor">Filename</span>.current_dir_name</code></a>. If not specified, the directory is taken from
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALget_temp_dir_name">
    <code class="code"><span class="constructor">Filename</span>.get_temp_dir_name</code></a>, which is typically set to your system
    temporary file directory.
<p>

    <code class="code">?prefix</code> helps determine the name of the file. It will be the prefix
    concatenated with a random sequence of characters. If not specified,
    <code class="code">open_temp_file</code> uses some default prefix.<br>
</div>

<pre><span id="VALwith_temp_file"><span class="keyword">val</span> with_temp_file</span> : <code class="type">?buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?flags:Unix.open_flag list -><br>       ?perm:Unix.file_perm -><br>       ?temp_dir:string -><br>       ?prefix:string -> (string * <a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a>) -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">with_temp_file&nbsp;f</code> calls <a href="Lwt_io.html#VALopen_temp_file"><code class="code"><span class="constructor">Lwt_io</span>.open_temp_file</code></a><code class="code">&nbsp;()</code>, passing all optional
    arguments directly to it. It then attaches <code class="code">f</code> to run after the file is
    created, passing the filename and output channel to <code class="code">f</code>. When the promise
    returned by <code class="code">f</code> is resolved, <code class="code">with_temp_file</code> closes the channel and deletes
    the temporary file by calling <a href="Lwt_unix.html#VALunlink"><code class="code"><span class="constructor">Lwt_unix</span>.unlink</code></a>.<br>
</div>

<pre><span id="VALopen_connection"><span class="keyword">val</span> open_connection</span> : <code class="type">?fd:<a href="Lwt_unix.html#TYPEfile_descr">Lwt_unix.file_descr</a> -><br>       ?in_buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?out_buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       Unix.sockaddr -> (<a href="Lwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Lwt_io.html#TYPEoutput_channel">output_channel</a>) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">open_connection&nbsp;?fd&nbsp;?in_buffer&nbsp;?out_buffer&nbsp;addr</code> opens a
      connection to the given address and returns two channels for using
      it. If <code class="code">fd</code> is not specified, a fresh one will be used.
<p>

      The connection is completly closed when you close both
      channels.<br>
<b>Raises</b> <code>Unix.Unix_error</code> on error.<br>
</div>

<pre><span id="VALwith_connection"><span class="keyword">val</span> with_connection</span> : <code class="type">?fd:<a href="Lwt_unix.html#TYPEfile_descr">Lwt_unix.file_descr</a> -><br>       ?in_buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       ?out_buffer:<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -><br>       Unix.sockaddr -><br>       (<a href="Lwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> 'a <a href="Lwt.html#TYPEt">Lwt.t</a>) -> 'a <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">with_connection&nbsp;?fd&nbsp;?in_buffer&nbsp;?out_buffer&nbsp;addr&nbsp;f</code> opens a
      connection to the given address and passes the channels to
      <code class="code">f</code><br>
</div>

<pre><span id="TYPEserver"><span class="keyword">type</span> <code class="type"></code>server</span> </pre>
<div class="info ">
Type of a server<br>
</div>


<pre><span id="VALestablish_server_with_client_address"><span class="keyword">val</span> establish_server_with_client_address</span> : <code class="type">?fd:<a href="Lwt_unix.html#TYPEfile_descr">Lwt_unix.file_descr</a> -><br>       ?buffer_size:int -><br>       ?backlog:int -><br>       ?no_close:bool -><br>       Unix.sockaddr -><br>       (<a href="Lwt_unix.html#TYPEsockaddr">Lwt_unix.sockaddr</a> -><br>        <a href="Lwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a>) -><br>       <a href="Lwt_io.html#TYPEserver">server</a> <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">establish_server_with_client_address&nbsp;listen_address&nbsp;f</code> creates a server
    which listens for incoming connections on <code class="code">listen_address</code>. When a client
    makes a new connection, it is passed to <code class="code">f</code>: more precisely, the server
    calls
<p>

<pre class="codepre"><code class="code">f client_address (in_channel, out_channel)
</code></pre>
<p>

    where <code class="code">client_address</code> is the address (peer name) of the new client, and
    <code class="code">in_channel</code> and <code class="code">out_channel</code> are two channels wrapping the socket for
    communicating with that client.
<p>

    The server does not block waiting for <code class="code">f</code> to complete: it concurrently tries
    to accept more client connections while <code class="code">f</code> is handling the client.
<p>

    When the promise returned by <code class="code">f</code> completes (i.e., <code class="code">f</code> is done handling the
    client), <code class="code">establish_server_with_client_address</code> automatically closes
    <code class="code">in_channel</code> and <code class="code">out_channel</code>. This is a default behavior that is useful
    for simple cases, but for a robust application you should explicitly close
    these channels yourself, and handle any exceptions. If the channels are
    still open when <code class="code">f</code> completes, and their automatic closing raises an
    exception, <code class="code">establish_server_with_client_address</code> treats it as an unhandled
    exception reaching the top level of the application: it passes that
    exception to <a href="Lwt.html#VALasync_exception_hook"><code class="code"><span class="constructor">Lwt</span>.async_exception_hook</code></a>, the default behavior of which is
    to print the exception and <em>terminate your process</em>.
<p>

    Automatic closing can be completely disabled by passing <code class="code">~no_close:<span class="keyword">true</span></code>.
<p>

    Similarly, if <code class="code">f</code> raises an exception (or the promise it returns fails with
    an exception), <code class="code">establish_server_with_client_address</code> can do nothing with
    that exception, except pass it to <a href="Lwt.html#VALasync_exception_hook"><code class="code"><span class="constructor">Lwt</span>.async_exception_hook</code></a>.
<p>

    <code class="code">~fd</code> can be specified to use an existing file descriptor for listening.
    Otherwise, a fresh socket is created internally.
<p>

    <code class="code">~backlog</code> is the argument passed to <a href="Lwt_unix.html#VALlisten"><code class="code"><span class="constructor">Lwt_unix</span>.listen</code></a>.
<p>

    The returned promise (a <code class="code">server&nbsp;<span class="constructor">Lwt</span>.t</code>) resolves when the server has just
    started listening on <code class="code">listen_address</code>: right after the internal call to
    <code class="code">listen</code>, and right before the first internal call to <code class="code">accept</code>.<br>
<b>Since</b> 3.1.0<br>
</div>

<pre><span id="VALshutdown_server"><span class="keyword">val</span> shutdown_server</span> : <code class="type"><a href="Lwt_io.html#TYPEserver">server</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
Closes the given server's listening socket. The returned promise resolves
    when the <code class="code">close(2)</code> system call completes. This function does not affect the
    sockets of connections that have already been accepted, i.e. passed to <code class="code">f</code>
    by <a href="Lwt_io.html#VALestablish_server"><code class="code"><span class="constructor">Lwt_io</span>.establish_server</code></a>.<br>
<b>Since</b> 3.0.0<br>
</div>

<pre><span id="VALlines_of_file"><span class="keyword">val</span> lines_of_file</span> : <code class="type"><a href="Lwt_io.html#TYPEfile_name">file_name</a> -> string <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a></code></pre><div class="info ">
<code class="code">lines_of_file&nbsp;name</code> returns a stream of all lines of the file
      with name <code class="code">name</code>. The file is automatically closed when all
      lines have been read.<br>
</div>

<pre><span id="VALlines_to_file"><span class="keyword">val</span> lines_to_file</span> : <code class="type"><a href="Lwt_io.html#TYPEfile_name">file_name</a> -> string <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">lines_to_file&nbsp;name&nbsp;lines</code> writes all lines of <code class="code">lines</code> to
      file with name <code class="code">name</code>.<br>
</div>

<pre><span id="VALchars_of_file"><span class="keyword">val</span> chars_of_file</span> : <code class="type"><a href="Lwt_io.html#TYPEfile_name">file_name</a> -> char <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a></code></pre><div class="info ">
<code class="code">chars_of_file&nbsp;name</code> returns a stream of all characters of the
      file with name <code class="code">name</code>. As for <a href="Lwt_io.html#VALlines_of_file"><code class="code"><span class="constructor">Lwt_io</span>.lines_of_file</code></a> the file is
      closed when all characters have been read.<br>
</div>

<pre><span id="VALchars_to_file"><span class="keyword">val</span> chars_to_file</span> : <code class="type"><a href="Lwt_io.html#TYPEfile_name">file_name</a> -> char <a href="Lwt_stream.html#TYPEt">Lwt_stream.t</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">chars_to_file&nbsp;name&nbsp;chars</code> writes all characters of <code class="code">chars</code> to
      <code class="code">name</code><br>
</div>
<br>
<h2 id="2_Inputoutputofintegers">Input/output of integers</h2><br>

<pre><span class="keyword">module type</span> <a href="Lwt_io.NumberIO.html">NumberIO</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Lwt_io.NumberIO.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Common interface for reading/writing integers in binary
</div>

<pre><span class="keyword">module</span> <a href="Lwt_io.LE.html">LE</a>: <code class="type"><a href="Lwt_io.NumberIO.html">NumberIO</a></code><code class="type"> </code></pre><div class="info">
Reading/writing of numbers in little-endian
</div>

<pre><span class="keyword">module</span> <a href="Lwt_io.BE.html">BE</a>: <code class="type"><a href="Lwt_io.NumberIO.html">NumberIO</a></code><code class="type"> </code></pre><div class="info">
Reading/writing of numbers in big-endian
</div>

<pre><span class="keyword">include</span> <a href="Lwt_io.NumberIO.html">Lwt_io.NumberIO</a></pre>
<br>
Reading/writing of numbers in the system endianness.<br>

<pre><span id="TYPEbyte_order"><span class="keyword">type</span> <code class="type"></code>byte_order</span> = <code class="type"><a href="Lwt_sys.html#TYPEbyte_order">Lwt_sys.byte_order</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbyte_order.Little_endian"><span class="constructor">Little_endian</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbyte_order.Big_endian"><span class="constructor">Big_endian</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Type of byte order<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="VALsystem_byte_order"><span class="keyword">val</span> system_byte_order</span> : <code class="type"><a href="Lwt_io.html#TYPEbyte_order">byte_order</a></code></pre><div class="info ">
Same as <a href="Lwt_sys.html#VALbyte_order"><code class="code"><span class="constructor">Lwt_sys</span>.byte_order</code></a>.<br>
</div>
<br>
<h2 id="2_Lowlevelaccesstotheinternalbuffer">Low-level access to the internal buffer</h2><br>

<pre><span id="VALblock"><span class="keyword">val</span> block</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> int -> (<a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a> -> int -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a>) -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">block&nbsp;ch&nbsp;size&nbsp;f</code> pass to <code class="code">f</code> the internal buffer and an
      offset. The buffer contains <code class="code">size</code> chars at <code class="code">offset</code>. <code class="code">f</code> may
      read or write these chars.  <code class="code">size</code> must satisfy <code class="code">0&nbsp;&lt;=&nbsp;size&nbsp;&lt;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16</code><br>
</div>

<pre><code><span id="TYPEdirect_access"><span class="keyword">type</span> <code class="type"></code>direct_access</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTdirect_access.da_buffer">da_buffer</span>&nbsp;: <code class="type"><a href="Lwt_bytes.html#TYPEt">Lwt_bytes.t</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The internal buffer<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTdirect_access.da_ptr">da_ptr</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The pointer to:<ul>
<li>the beginning of free space for output channels</li>
<li>the beginning of data for input channels</li>
</ul>
<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTdirect_access.da_max">da_max</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The maximum offset<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTdirect_access.da_perform">da_perform</span>&nbsp;: <code class="type">unit -> int <a href="Lwt.html#TYPEt">Lwt.t</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
- for input channels:
        refills the buffer and returns how many bytes have been read<ul>
<li>for output channels:
        flush partially the buffer and returns how many bytes have been written</li>
</ul>
<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
Information for directly accessing the internal buffer of a
    channel<br>
</div>


<pre><span id="VALdirect_access"><span class="keyword">val</span> direct_access</span> : <code class="type">'a <a href="Lwt_io.html#TYPEchannel">channel</a> -> (<a href="Lwt_io.html#TYPEdirect_access">direct_access</a> -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a>) -> 'b <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<code class="code">direct_access&nbsp;ch&nbsp;f</code> passes to <code class="code">f</code> a <a href="Lwt_io.html#VALdirect_access"><code class="code"><span class="constructor">Lwt_io</span>.direct_access</code></a>
      structure. <code class="code">f</code> must use it and update <code class="code">da_ptr</code> to reflect how
      many bytes have been read/written.<br>
</div>
<br>
<h2 id="2_Misc">Misc</h2><br>

<pre><span id="VALdefault_buffer_size"><span class="keyword">val</span> default_buffer_size</span> : <code class="type">unit -> int</code></pre><div class="info ">
Return the default size for buffers. Channels that are created
      without a specific buffer use new buffer of this size.<br>
</div>

<pre><span id="VALset_default_buffer_size"><span class="keyword">val</span> set_default_buffer_size</span> : <code class="type">int -> unit</code></pre><div class="info ">
Change the default buffer size.<br>
<b>Raises</b> <code>Invalid_argument</code> if the given size is smaller than <code class="code">16</code>
      or greater than <code class="code"><span class="constructor">Sys</span>.max_string_length</code><br>
</div>
<br>
<h2 id="2_Deprecated">Deprecated</h2><br>

<pre><span id="VALestablish_server"><span class="keyword">val</span> establish_server</span> : <code class="type">?fd:<a href="Lwt_unix.html#TYPEfile_descr">Lwt_unix.file_descr</a> -><br>       ?buffer_size:int -><br>       ?backlog:int -><br>       ?no_close:bool -><br>       Unix.sockaddr -><br>       (<a href="Lwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Lwt_io.html#TYPEoutput_channel">output_channel</a> -> unit <a href="Lwt.html#TYPEt">Lwt.t</a>) -><br>       <a href="Lwt_io.html#TYPEserver">server</a> <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info ">
<span class="warning">Deprecated.</span>Use <a href="Lwt_io.html#VALestablish_server_with_client_address"><code class="code"><span class="constructor">Lwt_io</span>.establish_server_with_client_address</code></a>.<br>
Like <code class="code">establish_server_with_client_address</code>, but does not pass the client
    address to the callback <code class="code">f</code>.<br>
<b>Since</b> 3.0.0<br>
</div>

<pre><span class="keyword">module</span> <a href="Lwt_io.Versioned.html">Versioned</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Lwt_io.Versioned.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Versioned variants of APIs undergoing breaking changes.
</div>
</body></html>